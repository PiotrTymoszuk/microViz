# Functions for calculation of set similarity (e.g. sets of differentially
# regulated genes)

#' @include imports.R

  NULL

# Similarity coefficients for vector pairs and lists of vectors ------

#' Similarity coefficients for pairs and ists of vectors.
#'
#' @description
#' The functions `vector_similarity()` and `set_similarity()` calculate the most
#' popular similarity coefficients for sets: Jaccard, overlap (also called
#' Szymkiewicz–Simpson index), Dice (Dice-Sørensen), and Tversky coefficients.
#' While `vector_similarity()` takes a pair of vectors as arguments and returns
#' a single numeric, `set_similarity()` operates on lists of vectors and returns
#' a matrix of similarity coefficients.
#'
#' @details
#' `set_similarity()` returns a matrix of class `set_sim` which can be handled
#' as a usual matrix and, in addition, allows for dimensionality reduction with
#' the \code{\link{components.set_sim}} method, and visualization of distances between
#' the list elements via \code{\link{plot.set_sim}}.
#' Those methods are useful at exploring similarity of e.g. sets of
#' differentially regulated genes identified in multiple data sets.
#'
#' @param x a vector coercible to a character vector (`vector similarity`) or
#' a list of such vectors (`set_similarity`).
#' @param y a vector coercible to a character vector.
#' @param method type of the coefficient.
#' @param a a single numeric, the alpha constant used for calculation of
#' the Tversky similarity coefficient.
#' @param b a single numeric, the beta constant used for calculation of
#' the Tversky similarity coefficient.
#'
#' @return a numeric (`vector_similarity()`) or a numeric matrix of similarity
#' coefficients (`set_similarity()`).
#'
#' @export

  vector_similarity <- function(x,
                                y,
                                method = c('jaccard',
                                           'overlap',
                                           'dice',
                                           'tversky'),
                                a = 1,
                                b = 1) {

    ## input control --------

    stopifnot(is.vector(x))
    stopifnot(is.vector(y))

    x <- as.character(x)
    y <- as.character(y)

    method <- match.arg(method[1],
                        c('jaccard',
                          'overlap',
                          'dice',
                          'tversky'))

    stopifnot(is.numeric(a))
    stopifnot(is.numeric(b))

    a <- a[1]
    b <- b[1]

    ## calculation -------

    if(method == 'tversky') return(vecTversky(x, y, a, b))

    return(vecSimilarity(x, y, method))

  }

#' @rdname vector_similarity
#' @export

  set_similarity <- function(x,
                             method = c('jaccard',
                                        'overlap',
                                        'dice',
                                        'tversky'),
                             a = 1,
                             b = 1) {

    ## input control --------

    stopifnot(is.list(x))

    x <- try(map(x, as.character), silent = TRUE)

    if(inherits(x, 'try-error')) {

      stop('Elements of the list are not coercible to character.',
           call. = TRUE)

    }

    method <- match.arg(method[1],
                        c('jaccard',
                          'overlap',
                          'dice',
                          'tversky'))

    stopifnot(is.numeric(a))
    stopifnot(is.numeric(b))

    a <- a[1]
    b <- b[1]

    ## calculation ------

    if(method == 'tversky') {

      res <- setTversky(x, a, b)

    } else {

      res <- setSimilarity(x, method)

    }

    x_names <- names(x)

    if(!is.null(x_names)) {

      colnames(res) <- x_names
      rownames(res) <- x_names

    }

    if(any(is.na(res))) {

      warning(paste('The similarity matrix contains NA: empty',
                    'sets included in the function input?'),
              call. = FALSE)

    }

    structure(res,
              class = c('set_sim', class(res)))

  }

# S3 OOP methods for the `set_sim` class  -------

#' Reduction analysis and visualization of similarities between sets.
#'
#' @description
#' `components()` and `plot()` methods for matrices of similarity between sets
#' generated by \code{\link{set_similarity}}.
#' `components()` performs dimensionality reduction of the similarity matrix
#' with MDS (`type = 'mds'`: multi-dimensional scaling) or UMAP
#' (`type = 'umap'`: uniform manifold approximation and projection),
#' or hierarchical clustering (`type = 'hcl'`).
#' `plot()` visualizes distances between the sets in form of heat map, MDS or
#' UMAP layouts, or as a dendrogram.
#'
#' @details
#' UMAP is computed with \code{\link[umap]{umap}}.
#'
#' @references
#' McInnes L, Healy J, Melville J. UMAP: Uniform Manifold Approximation and
#' Projection for Dimension Reduction. (2018)
#' Available at: https://arxiv.org/abs/1802.03426v3.
#'
#' @references
#' Konopka T. umap: Uniform Manifold Approximation and Projection. (2022)
#' Available at: https://cran.r-project.org/web/packages/umap/index.html
#'
#' @return `components()` returns a data frame with the MDS or UMAP layout
#' dimensions, or a `hclust` class object. `plot()` produces a `ggplot` object.
#'
#' @param object a similarity matrix returned by \code{\link{set_similarity}}.
#' @param x a similarity matrix returned by \code{\link{set_similarity}}.
#' @param type type of dimensionality reduction or plot.
#' @param k number of dimensions.
#' @param trans_fun function used to transform similarities to distances.
#' @param method algorithm of hierarchical clustering, see:
#' \code{\link[stats]{hclust}} for details.
#' @param point_size size of the data points.
#' @param point_alpha alpha of the the points.
#' @param point_color color of the points.
#' @param point_wjitter horizontal jittering of the points.
#' @param point_hjitter vertical jittering of the points.
#' @param order_by_similarity ordering of the heat map tiles by descending of
#' ascending similarities. 'none' (default): the set order corresponds to the
#' order of the sets in the input matrix.
#' @param tile_rim color of rims of tiles of the heat map.
#' @param show_txt logical, should names of the sets be displayed in the plots?
#' @param txt_size size of the set names label text.
#' @param txt_color color of the text.
#' @param txt_alpha alpha of the text.
#' @param txt_face face of the text.
#' @param labeller function used to transform set names prior to displaying them
#' in the plot.
#' @param cust_theme custom `ggplot` theme.
#' @param ... for `components()`: additional arguments passed to
#' \code{\link[stats]{cmdscale}}, \code{\link[umap]{umap}},
#' or \code{\link[stats]{hclust}};
#' for `plot()`: extra arguments passed to \code{\link{components.set_sim}} or
#' \code{\link[ggdendro]{ggdendrogram}}.
#'
#' @export components.set_sim
#' @export

  components.set_sim <- function(object,
                                 type = c('mds', 'umap', 'hcl'),
                                 k = 2,
                                 trans_fun = function(x) 1 - x,
                                 method = 'complete', ...) {

    ## input control -------

    stopifnot(inherits(object, 'set_sim'))

    type <- match.arg(type[1], c('mds', 'umap', 'hcl'))

    stopifnot(is.numeric(k))

    k <- as.integer(k[1])

    stopifnot(k >= 2)

    stopifnot(is.function(trans_fun))

    ## transformation of the matrix --------

    object <- trans_fun(as.matrix(object))

    if(is.null(rownames(as.matrix(object)))) {

      dim <- nrow(object)

      new_names <- paste0('set_', 1:dim)

      rownames(object) <- new_names
      colnames(object) <- new_names

    }

    ## dimensionality reduction --------

    if(type %in% c('mds', 'umap')) {

      if(type == 'mds') {

        object <- as.dist(object)

        red_mat <- cmdscale(object, k = k, ...)

      } else {

        red_mat <- umap(as.matrix(object),
                        n_components = k,
                        input = 'dist', ...)

        red_mat <- red_mat$layout

      }

      colnames(red_mat) <- paste0('comp_', 1:k)

      set <- NULL

      red_mat <- rownames_to_column(as.data.frame(red_mat), 'set')

      return(as_tibble(relocate(red_mat, set)))

    }

    ## hierarchical clustering ------

    object <- as.dist(object)

    return(hclust(object, method = method, ...))

  }

#' @rdname components.set_sim
#' @export plot.set_sim
#' @export

  plot.set_sim <- function(x,
                           type = c('heat_map', 'mds', 'umap', 'dendrogram'),
                           trans_fun = function(x) 1 - x,
                           method = 'complete',
                           point_size = 2,
                           point_alpha = 1,
                           point_color = 'steelblue',
                           point_wjitter = 0,
                           point_hjitter = 0,
                           order_by_similarity = c('none',
                                                   'descending',
                                                   'ascending'),
                           tile_rim = 'black',
                           show_txt = TRUE,
                           txt_size = 2.75,
                           txt_color = 'black',
                           txt_alpha = 1,
                           txt_face = 'plain',
                           labeller = identity,
                           cust_theme = theme_micro(), ...) {

    ## entry control -------

    stopifnot(inherits(x, 'set_sim'))

    type <- match.arg(type[1],
                      c('heat_map', 'mds', 'umap', 'dendrogram'))

    stopifnot(is.numeric(point_size))
    stopifnot(is.numeric(point_alpha))
    stopifnot(is.numeric(point_wjitter))
    stopifnot(is.numeric(point_hjitter))

    stopifnot(point_wjitter >= 0)
    stopifnot(point_hjitter >= 0)

    stopifnot(is.logical(show_txt))
    stopifnot(is.numeric(txt_size))
    stopifnot(is.function(labeller))

    stopifnot(inherits(cust_theme, 'theme'))

    order_by_similarity <-
      match.arg(order_by_similarity[1],
                c('none', 'descending', 'ascending'))

    ## plot settings -------

    x <- as.matrix(x)

    if(is.null(rownames(x))) {

      new_names <- paste0('set_', 1:nrow(x))

      rownames(x) <- new_names
      colnames(x) <- new_names

    }

    n_sets <- nrow(x)

    plot_subtitle <- paste('sets: n =', n_sets)

    plot_title <- switch(type,
                         heat_map = 'Similarity of sets',
                         mds = 'MDS of similarity matrix',
                         umap = 'UMAP of similarity matrix',
                         dendrogram = 'Similarity of sets')

    ## heat map plotting --------

    if(type == 'heat_map') {

      ### plotting data

      plot_data <- as.data.frame(x)

      vars <- names(plot_data)

      variable1 <- NULL
      variable2 <- NULL
      simil <- NULL

      plot_data <- rownames_to_column(plot_data, 'variable1')

      plot_data <- pivot_longer(plot_data,
                                cols = all_of(vars),
                                values_to = 'simil',
                                names_to = 'variable2')

      plot_data <- mutate(plot_data,
                          variable1 = factor(variable1, vars),
                          variable2 = factor(variable2, vars))

      ### heat map

      if(order_by_similarity == 'none') {

        hm_plot <- ggplot(plot_data,
                          aes(x = variable1,
                              y = variable2,
                              fill = simil))

      } else if(order_by_similarity == 'ascending') {

        hm_plot <- ggplot(plot_data,
                          aes(x = reorder(variable1, simil),
                              y = reorder(variable2, simil),
                              fill = simil))

      } else {

        hm_plot <- ggplot(plot_data,
                          aes(x = reorder(variable1, -simil),
                              y = reorder(variable2, -simil),
                              fill = simil))

      }

      hm_plot <- hm_plot +
        geom_tile(color = tile_rim) +
        cust_theme +
        labs(title = plot_title,
             subtitle = plot_subtitle,
             x = 'set',
             y = 'set',
             fill = 'Similarity')

      return(hm_plot)

    }

    ## MDS and UMAP layouts --------

    if(type %in% c('mds', 'umap')) {

      ### plotting data

      plot_data <- components(x,
                              type = type,
                              trans_fun = trans_fun, ...)

      plot_data <- plot_data[c('set', 'comp_1', 'comp_2')]

      x_offset <- 0
      y_offset <- 0

      if(point_wjitter != 0) {

        x_offset <- rnorm(nrow(plot_data), 0, point_wjitter)

      }

      if(point_hjitter != 0) {

        y_offset <- rnorm(nrow(plot_data), 0, point_hjitter)

      }

      x_shift <- NULL
      y_shift <- NULL

      plot_data <- mutate(plot_data,
                          x_shift = x_offset,
                          y_shift = y_offset)

      ### scatter plot

      comp_1 <- NULL
      comp_2 <- NULL

      lab_prefix <- switch(type,
                           mds = 'MDS',
                           umap = 'UMAP')

      red_plot <-
        ggplot(plot_data,
               aes(x = comp_1 + x_offset,
                   y = comp_2 + x_offset)) +
        geom_point(shape = 21,
                   size = point_size,
                   alpha = point_alpha,
                   fill = point_color) +
        cust_theme +
        labs(title = plot_title,
             subtitle = plot_subtitle,
             x = paste0(lab_prefix, 1),
             y = paste0(lab_prefix, 2))

      if(show_txt) {

        set <- NULL

        red_plot <- red_plot +
          geom_text_repel(aes(label = labeller(set)),
                          size = txt_size,
                          alpha = txt_alpha,
                          color = txt_color,
                          fontface = txt_face)


      }

      return(red_plot)

    }

    ## dendrogram plotting --------

    plot_data <- components(x,
                            type = 'hcl',
                            trans_fun = trans_fun,
                            method = method)

    den_plot <- ggdendrogram(data = plot_data, ...)

    den_plot +
      cust_theme +
      theme(panel.grid.major = element_blank(),
            panel.grid.minor = element_blank()) +
      labs(title = plot_title,
           subtitle = plot_subtitle,
           y = 'distance')

  }

# END -------
